<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Location Share (Google Maps)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the map container */
        #map {
            height: calc(100vh - 120px); /* Full height minus header/controls area */
            width: 100%;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .auth-container {
            height: calc(100vh - 120px);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Custom styling for the InfoWindow content */
        .info-window {
            font-size: 0.875rem; /* text-sm */
        }
    </style>
    <!-- Google Maps API Script - Includes all necessary services -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDCBD8y02er5VSinumFXBmAFEtsg2oYz9I&libraries=places"></script>
</head>
<body class="p-4 md:p-6">

    <header class="mb-4 flex flex-col md:flex-row justify-between items-center bg-white p-4 rounded-xl shadow-lg">
        <h1 class="text-2xl font-extrabold text-gray-800 mb-2 md:mb-0">
            <svg class="inline w-6 h-6 mr-2 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Real-Time Location Share
        </h1>
        <div class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4">
            <span id="user-id-display" class="text-xs font-mono text-gray-500 bg-gray-100 p-2 rounded-lg truncate w-full sm:w-auto">
                Connecting...
            </span>
            <button id="logout-btn" class="hidden w-full sm:w-auto px-4 py-2 text-white bg-gray-500 hover:bg-gray-600 font-semibold rounded-lg transition duration-150 ease-in-out shadow-md">
                Logout
            </button>
            <button id="toggle-tracking-btn" class="hidden w-full sm:w-auto px-4 py-2 text-white font-semibold rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" disabled>
                Start Sharing Location
            </button>
        </div>
    </header>

    <!-- Map container (Hidden until authenticated) -->
    <div id="map" class="hidden"></div>

    <!-- Authentication Forms Container -->
    <div id="auth-container" class="auth-container">
        <!-- Login Form -->
        <div id="login-card" class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md transition duration-300">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">Login</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="login-email" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-4 relative">
                    <label for="login-password" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="login-password" required minlength="6" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    <div class="mt-2 flex items-center">
                        <input type="checkbox" id="login-show-password" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <label for="login-show-password" class="ml-2 block text-sm text-gray-900">Show Password</label>
                    </div>
                </div>
                <p id="login-error" class="text-red-500 text-sm mb-4 hidden"></p>
                <button type="submit" class="w-full bg-blue-600 text-white py-2 rounded-lg font-semibold hover:bg-blue-700 transition duration-150 shadow-md">
                    Log In
                </button>
            </form>
            <p class="mt-4 text-center text-sm text-gray-600">
                Don't have an account? <button id="switch-to-register" class="text-blue-600 hover:text-blue-700 font-medium">Register here</button>
            </p>
        </div>

        <!-- Registration Form (Initially Hidden) -->
        <div id="register-card" class="hidden bg-white p-8 rounded-xl shadow-2xl w-full max-w-md transition duration-300">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">Register</h2>
            <form id="register-form">
                <!-- USERNAME FIELD -->
                <div class="mb-4">
                    <label for="register-username" class="block text-sm font-medium text-gray-700">Username</label>
                    <input type="text" id="register-username" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <!-- END USERNAME FIELD -->
                <div class="mb-4">
                    <label for="register-email" class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="register-email" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-4 relative">
                    <label for="register-password" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="register-password" required minlength="6" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-4 relative">
                    <label for="register-confirm-password" class="block text-sm font-medium text-gray-700">Confirm Password</label>
                    <input type="password" id="register-confirm-password" required minlength="6" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    <div class="mt-2 flex items-center">
                        <input type="checkbox" id="register-show-password" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <label for="register-show-password" class="ml-2 block text-sm text-gray-900">Show Passwords</label>
                    </div>
                </div>
                <p id="register-error" class="text-red-500 text-sm mb-4 hidden"></p>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded-lg font-semibold hover:bg-green-700 transition duration-150 shadow-md">
                    Register
                </button>
            </form>
            <p class="mt-4 text-center text-sm text-gray-600">
                Already have an account? <button id="switch-to-login" class="text-blue-600 hover:text-blue-700 font-medium">Log in here</button>
            </p>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";

        // IMPORTANT: Set debug logging for Firestore
        setLogLevel('Debug');

        // Hardcoded Firebase configuration provided by the user (overrides __firebase_config)
        const userProvidedFirebaseConfig = {
            apiKey: "AIzaSyCbr-2Hvxg4AEfFb51lGoYYepxLOie4JiQ",
            authDomain: "track-your-journey.firebaseapp.com",
            projectId: "track-your-journey",
            storageBucket: "track-your-journey.firebasestorage.app",
            messagingSenderId: "766067811321",
            appId: "1:766067811321:web:0dadf42158bc72cafb9328",
            measurementId: "G-BS033MFRVY"
        };

        // Global variables required by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, analytics;
        let userId = 'anonymous'; // Default value, updated on successful auth
        /** @type {google.maps.Map} */
        let map;
        /** @type {google.maps.Geocoder} */
        let geocoder; // New global Geocoder instance
        let isTracking = false;
        let watchId = null;
        /** @type {Object<string, google.maps.Marker>} */
        const userMarkers = {}; // Object to store Google Maps markers: { userId: markerInstance }
        /** @type {Object<string, google.maps.InfoWindow>} */
        const infoWindows = {}; // Object to store Google Maps InfoWindow instances
        /** @type {Object<string, string>} */
        const userAddresses = {}; // Cache for addresses: { userId: "Street Address, City" }
        let isMapCentered = false; // Flag to force map centering and zooming on location start
        
        // --- GLOBAL OBJECTS FOR PATH TRACKING ---
        /** @type {Object<string, google.maps.Polyline>} */
        const userPolylines = {}; // { userId: PolylineInstance }
        /** @type {Object<string, Array<{lat: number, lng: number}>>} */
        const userPaths = {};     // { userId: [{lat, lng}, ...] }
        // -------------------------------------------


        // --- DOM Elements ---
        const toggleBtn = document.getElementById('toggle-tracking-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const userIdDisplay = document.getElementById('user-id-display');
        const mapContainer = document.getElementById('map');
        const authContainer = document.getElementById('auth-container');
        const loginCard = document.getElementById('login-card');
        const registerCard = document.getElementById('register-card');

        // Login Form Elements
        const loginForm = document.getElementById('login-form');
        const loginEmail = document.getElementById('login-email');
        const loginPassword = document.getElementById('login-password');
        const loginShowPassword = document.getElementById('login-show-password');
        const loginError = document.getElementById('login-error');

        // Registration Form Elements
        const registerForm = document.getElementById('register-form');
        const registerUsername = document.getElementById('register-username'); 
        const registerEmail = document.getElementById('register-email');
        const registerPassword = document.getElementById('register-password');
        const registerConfirmPassword = document.getElementById('register-confirm-password');
        const registerShowPassword = document.getElementById('register-show-password');
        const registerError = document.getElementById('register-error');

        // --- Custom Google Maps Icon Definitions (All Red, Self is Brighter/Larger) ---
        const MY_MARKER_ICON = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#ef4444', // Bright Red (red-500)
            fillOpacity: 1,
            strokeWeight: 4,
            strokeColor: '#fecaca', // Light Pink/Red outline
            scale: 8, // Larger size for self
        };
        const OTHER_MARKER_ICON = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#dc2626', // Darker Red (red-600)
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: '#fca5a5', // Lighter Red outline
            scale: 6, // Standard size for others
        };


        // --- Utility Functions ---

        /**
         * Safely gets the Firestore document path for a public collection.
         * @param {string} collectionName
         * @returns {string} The full path.
         */
        const getPublicCollectionPath = (collectionName) => {
            return `/artifacts/${appId}/public/data/${collectionName}`;
        };

        /**
         * Generates a consistent hex color from a string ID (for polyline colors).
         * @param {string} id - The user ID.
         * @returns {string} A hex color string (e.g., #A3B5C7).
         */
        const getColorFromId = (id) => {
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return "#" + "00000".substring(0, 6 - c.length) + c;
        };
        
        // ... (Utility functions for UI and Auth handlers remain the same) ...
        const toggleAppUI = (isAuthenticated) => {
            if (isAuthenticated) {
                mapContainer.classList.remove('hidden');
                toggleBtn.classList.remove('hidden');
                logoutBtn.classList.remove('hidden');
                authContainer.classList.add('hidden');
            } else {
                mapContainer.classList.add('hidden');
                toggleBtn.classList.add('hidden');
                logoutBtn.classList.add('hidden');
                authContainer.classList.remove('hidden');
            }
        };

        const togglePasswordVisibility = (type) => {
            if (type === 'login') {
                loginPassword.type = loginShowPassword.checked ? 'text' : 'password';
            } else if (type === 'register') {
                const isChecked = registerShowPassword.checked;
                registerPassword.type = isChecked ? 'text' : 'password';
                registerConfirmPassword.type = isChecked ? 'text' : 'password';
            }
        };
        
        const showModal = (message) => {
            const existingModal = document.getElementById('custom-modal');
            if (existingModal) existingModal.remove();

            const modalHtml = `
                <div id="custom-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300">
                    <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 md:w-1/3">
                        <h3 class="text-lg font-bold text-red-600 mb-4">Notification</h3>
                        <p class="text-gray-700 mb-6">${message}</p>
                        <button id="modal-close-btn" class="w-full bg-blue-500 text-white py-2 rounded-lg font-semibold hover:bg-blue-600 transition duration-150">
                            OK
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            document.getElementById('modal-close-btn').onclick = () => {
                document.getElementById('custom-modal').remove();
            };
        };


        // --- Firebase Initialization and Authentication ---

        const initializeFirebase = async () => {
            try {
                // Initialize Firebase App using the user-provided config
                app = initializeApp(userProvidedFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                getAnalytics(app); // Initialize Analytics

                // Set up auth state change listener
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        const displayIdentifier = user.displayName || user.email || userId;
                        userIdDisplay.textContent = `User: ${displayIdentifier}`;
                        
                        if (!user.isAnonymous && initialAuthToken) {
                        } else if (user.isAnonymous && initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            return; 
                        }

                        toggleAppUI(true);
                        toggleBtn.disabled = false;
                        toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500', 'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
                        toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');

                        setupRealTimeLocationListener();
                    } else {
                        userId = 'anonymous';
                        userIdDisplay.textContent = 'Please log in';
                        toggleAppUI(false);

                        if (!initialAuthToken) {
                             await signInAnonymously(auth);
                        } else {
                             userIdDisplay.textContent = 'Token Auth Failed. Log in manually.';
                        }
                    }
                });


            } catch (error) {
                console.error("Error initializing Firebase:", error.message);
                userIdDisplay.textContent = 'Error: Check Console';
            }
        };

        // --- Auth Handlers (omitted for brevity, assume unchanged) ---
        const handleRegistration = async (e) => {
            e.preventDefault();
            registerError.classList.add('hidden');
            const username = registerUsername.value.trim();
            const email = registerEmail.value;
            const password = registerPassword.value;
            const confirmPassword = registerConfirmPassword.value;

            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match.';
                registerError.classList.remove('hidden');
                return;
            }

            if (password.length < 6) {
                registerError.textContent = 'Password must be at least 6 characters.';
                registerError.classList.remove('hidden');
                return;
            }
            
            if (username.length === 0) {
                 registerError.textContent = 'Username is required.';
                registerError.classList.remove('hidden');
                return;
            }


            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await updateProfile(userCredential.user, { displayName: username });
            } catch (error) {
                console.error("Registration Error:", error.message);
                registerError.textContent = `Registration failed: ${error.message}`;
                registerError.classList.remove('hidden');
            }
        };

        const handleLogin = async (e) => {
            e.preventDefault();
            loginError.classList.add('hidden');
            const email = loginEmail.value;
            const password = loginPassword.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Login Error:", error.message);
                loginError.textContent = 'Login failed. Check email and password.';
                loginError.classList.remove('hidden');
            }
        };

        const handleLogout = async () => {
            if (isTracking) {
                await stopTracking(); 
            }
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Logout Error:", error.message);
                showModal("Logout failed. Please try again.");
            }
        };

        // --- Geolocation and Firestore Data Management ---
        const updateFirestoreLocation = async (lat, lng, isTracking) => {
            if (!db || !userId || userId === 'anonymous') return;

            const userDocRef = doc(db, getPublicCollectionPath('user_locations'), userId);

            if (isTracking) {
                const data = {
                    lat: lat,
                    lng: lng,
                    timestamp: new Date().getTime(),
                    displayId: auth.currentUser.displayName || auth.currentUser.email || userId,
                    isTracking: true
                };
                await setDoc(userDocRef, data);
            } else {
                await deleteDoc(userDocRef);
                removeMarker(userId);
                // Clear the address cache for the user who stopped tracking
                delete userAddresses[userId]; 
            }
        };

        const geoSuccess = (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const pos = { lat, lng };

            // Update UI to final tracking state (Red Button)
            toggleBtn.textContent = 'Stop Sharing Location';
            toggleBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
            toggleBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');


            // 1. Update own location in public Firestore
            updateFirestoreLocation(lat, lng, true);

            // 2. Center map and zoom in on start (if flag is set)
            if (map && isMapCentered) { 
                 map.setCenter(pos);
                 map.setZoom(15); 
                 isMapCentered = false; 
            }
        };

        const geoError = (error) => {
            console.error("Geolocation Error:", error.message);
            showModal(`Location Error: ${error.message}. Please enable location permissions.`);

            isTracking = false;
            toggleBtn.textContent = 'Start Sharing Location';
            toggleBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500', 'bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');
            toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
        };

        const startTracking = () => {
            if (!navigator.geolocation) {
                showModal("Geolocation is not supported by this browser.");
                return;
            }

            isMapCentered = true;

            // Update UI to 'Waiting' state immediately (Yellow Button)
            isTracking = true;
            toggleBtn.textContent = 'Waiting for location...';
            toggleBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500', 'bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');
            toggleBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');

            watchId = navigator.geolocation.watchPosition(geoSuccess, geoError, {
                enableHighAccuracy: true,
                maximumAge: 5000,
                timeout: 10000
            });
        };

        const stopTracking = async () => {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // 2. Immediately update local state and UI
            isTracking = false;
            toggleBtn.textContent = 'Start Sharing Location';
            toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500', 'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
            toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');

            // 3. Perform asynchronous cleanup on Firestore
            await updateFirestoreLocation(0, 0, false);
        };

        // --- Map and Marker Management (Google Maps) ---

        /**
         * Initializes the Google map and the Geocoder service.
         */
        const initializeMap = () => {
            map = new google.maps.Map(mapContainer, {
                center: { lat: 0, lng: 0 }, 
                zoom: 2,
                mapId: "DEMO_MAP_ID"
            });
            // Initialize the Geocoder service
            geocoder = new google.maps.Geocoder();
            console.log("Google Map and Geocoder initialized.");
        };

        const setupRealTimeLocationListener = () => {
            if (!db) return;

            const colRef = collection(db, getPublicCollectionPath('user_locations'));

            onSnapshot(colRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const targetUserId = change.doc.id;
                    const displayId = data.displayId || targetUserId; 

                    if (change.type === "removed" || !data.isTracking) {
                        removeMarker(targetUserId);
                    } else if (change.type === "added" || change.type === "modified") {
                        updateMarker(targetUserId, data.lat, data.lng, data.timestamp, displayId);
                    }
                });
            }, (error) => {
                console.error("Error listening to Firestore location updates:", error);
            });
        };
        
        /**
         * Fetches the street address for a given position using the Geocoder service.
         * @param {google.maps.LatLngLiteral} position - {lat: number, lng: number}.
         * @param {string} id - User ID to cache the result.
         * @param {Function} callback - Function to call with the formatted address string.
         */
        const fetchAddress = (position, id, callback) => {
            if (!geocoder) {
                callback("Address service not ready.");
                return;
            }

            // Check cache first
            if (userAddresses[id] && userPaths[id].length > 0 && userPaths[id].length > userAddresses[id].lastPathLength) {
                // If the path length hasn't changed much since last update, use cache
                // Note: The logic here is simplified. For production, you'd use a bounding box comparison.
                // For now, we will just clear cache on movement and always attempt geocode.
                // Reset cache to allow new lookup
                delete userAddresses[id]; 
            }

            if (userAddresses[id]) {
                callback(userAddresses[id].address);
                return;
            }

            geocoder.geocode({ 'location': position }, (results, status) => {
                let address = "Address Lookup Failed";
                if (status === 'OK' && results[0]) {
                    // Use the first (most accurate) result's formatted address
                    address = results[0].formatted_address;
                } else if (status === 'ZERO_RESULTS') {
                    address = "No street address found.";
                } else {
                    console.error("Geocoder failed due to: " + status);
                    address = "Error fetching address...";
                }
                
                // Cache the result
                userAddresses[id] = { 
                    address: address, 
                    lastPathLength: userPaths[id] ? userPaths[id].length : 0 
                };

                // Call the callback to update the InfoWindow
                callback(address);
            });
        };


        /**
         * Updates or creates a marker and its corresponding movement line on the map.
         */
        const updateMarker = (id, lat, lng, timestamp, displayId) => {
            const isSelf = id === userId;
            const position = { lat: lat, lng: lng };
            const icon = isSelf ? MY_MARKER_ICON : OTHER_MARKER_ICON;
            const timeString = new Date(timestamp).toLocaleTimeString();
            const markerTitle = isSelf ? `👑 Your Location (You: ${displayId})` : `📍 User: ${displayId}`;

            let marker = userMarkers[id];
            let infoWindow = infoWindows[id];

            // 1. Marker Logic
            if (marker) {
                marker.setPosition(position);
                marker.setIcon(icon);
                marker.setTitle(markerTitle);
            } else {
                marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: markerTitle, 
                    icon: icon,
                });

                userMarkers[id] = marker;

                // Create InfoWindow with initial "Loading..." content
                infoWindow = new google.maps.InfoWindow({ content: 'Loading address...' });
                infoWindows[id] = infoWindow;

                // Add click listener to show InfoWindow
                marker.addListener('click', () => {
                    Object.values(infoWindows).forEach(iw => iw.close());
                    infoWindow.open({ anchor: marker, map: map, shouldFocus: false });
                });
            }

            // 2. InfoWindow Content & Reverse Geocoding
            
            // Immediately update InfoWindow with coordinates/time, and request the address
            const updateInfoWindowContent = (address) => {
                const popupContent = `
                    <div class="info-window p-1">
                        <div class="text-base font-bold mb-1" style="color: ${isSelf ? '#dc2626' : '#374151'};">${markerTitle}</div>
                        <div class="font-semibold text-gray-800 break-words">${address}</div>
                        <div class="text-xs text-gray-500 mt-1">Lat/Lng: ${lat.toFixed(6)}, ${lng.toFixed(6)}</div>
                        <div class="text-xs text-gray-500">Last Seen: ${timeString}</div>
                    </div>
                `;
                infoWindow.setContent(popupContent);
                
                // If the InfoWindow is currently open, force a refresh/re-open to display the new address
                if (infoWindow.getMap()) {
                     infoWindow.open({ anchor: marker, map: map, shouldFocus: false });
                }
            };
            
            // Set initial content while address is loading or use cached value
            const initialAddress = (userAddresses[id] && userAddresses[id].address) || "Loading current address...";
            updateInfoWindowContent(initialAddress);

            // Call fetchAddress only if a valid geocoder exists
            if (geocoder) {
                fetchAddress(position, id, updateInfoWindowContent);
            }


            // If it's the current user's marker, pan the map to follow if they are actively tracking
            if (isSelf && isTracking) {
                map.panTo(position);
            }

            // 3. Polyline (Movement Tracking) Logic
            if (!userPaths[id]) {
                userPaths[id] = [];
            }
            
            const lastPos = userPaths[id][userPaths[id].length - 1];
            // Only add if position is significantly different
            const isDifferent = !lastPos || (lastPos.lat.toFixed(6) !== lat.toFixed(6) || lastPos.lng.toFixed(6) !== lng.toFixed(6));
            
            if (isDifferent) {
                userPaths[id].push(position);
            }

            let polyline = userPolylines[id];
            const lineColor = isSelf ? '#ef4444' : getColorFromId(id); 
            
            if (polyline) {
                polyline.setPath(userPaths[id]);
            } else {
                polyline = new google.maps.Polyline({
                    path: userPaths[id],
                    geodesic: true,
                    strokeColor: lineColor,
                    strokeOpacity: isSelf ? 1.0 : 0.8,
                    strokeWeight: isSelf ? 5 : 3, 
                    map: map,
                });
                userPolylines[id] = polyline;
            }
        };

        const removeMarker = (id) => {
            if (userMarkers[id]) {
                userMarkers[id].setMap(null);
                delete userMarkers[id];
            }

            if (userPolylines[id]) {
                userPolylines[id].setMap(null); 
                delete userPolylines[id];
            }
            if (userPaths[id]) {
                delete userPaths[id]; 
            }
            
            if(infoWindows[id]) {
                infoWindows[id].close();
                delete infoWindows[id];
            }
            
            // Clear address cache for removed user
            if(userAddresses[id]) {
                delete userAddresses[id];
            }
        };

        // --- Event Listeners and Initial Setup ---

        // Toggle tracking
        toggleBtn.addEventListener('click', async () => {
            if (isTracking) {
                await stopTracking();
            } else {
                startTracking();
            }
        });

        // Toggle login/register card views
        document.getElementById('switch-to-register').addEventListener('click', () => {
            loginCard.classList.add('hidden');
            registerCard.classList.remove('hidden');
            loginError.classList.add('hidden'); 
        });
        document.getElementById('switch-to-login').addEventListener('click', () => {
            registerCard.classList.add('hidden');
            loginCard.classList.remove('hidden');
            registerError.classList.add('hidden'); 
        });

        // Form submissions
        loginForm.addEventListener('submit', handleLogin);
        registerForm.addEventListener('submit', handleRegistration);
        logoutBtn.addEventListener('click', handleLogout);

        // Password visibility toggles
        loginShowPassword.addEventListener('change', () => togglePasswordVisibility('login'));
        registerShowPassword.addEventListener('change', () => togglePasswordVisibility('register'));

        // Initialize map and Firebase when the window loads
        window.onload = async () => {
            await initializeFirebase();

            // Wait until Google Maps API script is loaded
            const mapLoadCheck = setInterval(() => {
                if (typeof google !== 'undefined' && google.maps) {
                    clearInterval(mapLoadCheck);
                    initializeMap(); // Calls initializeMap, which sets up the Geocoder
                }
            }, 100);
        };
    </script>
</body>
</html>
