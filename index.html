<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Location Share - Offline Ready</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font import for aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* 1. Full-screen centering for the Auth card */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb; /* Light background */
            min-height: 100vh;
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 1rem; 
            margin: 0;
            flex-direction: column; /* Allows content flow if not centered */
        }
        
        /* 2. Map height when the app is visible */
        #map {
            height: calc(100vh - 220px); /* Adjusted height for full app view */
            width: 100%;
            border-radius: 1rem; 
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.15);
        }
        
        /* Info window style */
        .info-window {
            font-size: 0.875rem;
        }

        /* Override body centering when the main app is active (handled by JS) */
        .app-active-layout {
            display: block !important;
            padding: 1.5rem;
        }
    </style>
    <!-- Google Maps API Script - Includes all necessary services -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDCBD8y02er5VSinumFXBmAFEtsg2oYz9I&libraries=places"></script>
</head>
<body class="p-4 md:p-6">

    <!-- AUTHENTICATION FORMS CONTAINER (Only visible before login, centered) -->
    <div id="auth-container" class="w-full max-w-md">
        <div class="bg-white p-8 md:p-10 rounded-2xl shadow-2xl w-full transition duration-300 border border-gray-200">
            
            <!-- Login Card (Default Visible) -->
            <div id="login-card">
                <!-- Title Section -->
                <div class="flex flex-col items-center mb-6">
                    <svg class="w-10 h-10 text-indigo-600 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"></path></svg>
                    <h2 class="text-3xl font-extrabold text-indigo-700 text-center">Welcome Back</h2>
                    <p class="mt-1 text-sm text-gray-500">Sign in to start tracking</p>
                </div>

                <form id="login-form">
                    <div class="mb-4">
                        <label for="login-email" class="block text-sm font-medium text-gray-700">Email</label>
                        <input type="email" id="login-email" required class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="mb-4 relative">
                        <label for="login-password" class="block text-sm font-medium text-gray-700">Password</label>
                        <input type="password" id="login-password" required minlength="6" class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <div class="mt-2 flex items-center">
                            <input type="checkbox" id="login-show-password" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                            <label for="login-show-password" class="ml-2 block text-sm text-gray-900">Show Password</label>
                        </div>
                    </div>
                    <p id="login-error" class="text-red-500 text-sm mb-4 hidden font-medium"></p>
                    <button type="submit" class="w-full bg-indigo-600 text-white py-3 px-4 rounded-xl font-bold hover:bg-indigo-700 transition duration-200 shadow-lg shadow-indigo-500/50 active:scale-[0.99]">
                        Log In
                    </button>
                </form>
                <p class="mt-6 text-center text-sm text-gray-600">
                    Need an account? <button id="switch-to-register" class="text-green-600 hover:text-green-800 font-extrabold hover:underline">Register here</button>
                </p>
            </div>

            <!-- Registration Card (Initially Hidden) -->
            <div id="register-card" class="hidden">
                <!-- Title Section -->
                <div class="flex flex-col items-center mb-6">
                    <svg class="w-10 h-10 text-green-600 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                    <h2 class="text-3xl font-extrabold text-green-700 text-center">Create Account</h2>
                    <p class="mt-1 text-sm text-gray-500">Join the map in minutes</p>
                </div>

                <form id="register-form">
                    <div class="mb-4">
                        <label for="register-username" class="block text-sm font-medium text-gray-700">Username</label>
                        <input type="text" id="register-username" required class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500">
                    </div>
                    <div class="mb-4">
                        <label for="register-email" class="block text-sm font-medium text-gray-700">Email</label>
                        <input type="email" id="register-email" required class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500">
                    </div>
                    <div class="mb-4 relative">
                        <label for="register-password" class="block text-sm font-medium text-gray-700">Password</label>
                        <input type="password" id="register-password" required minlength="6" class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500">
                    </div>
                    <div class="mb-4 relative">
                        <label for="register-confirm-password" class="block text-sm font-medium text-gray-700">Confirm Password</label>
                        <input type="password" id="register-confirm-password" required minlength="6" class="mt-1 block w-full px-4 py-3 border-2 border-gray-200 rounded-xl shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500">
                        <div class="mt-2 flex items-center">
                            <input type="checkbox" id="register-show-password" class="h-4 w-4 text-green-600 border-gray-300 rounded focus:ring-green-500">
                            <label for="register-show-password" class="ml-2 block text-sm text-gray-900">Show Passwords</label>
                        </div>
                    </div>
                    <p id="register-error" class="text-red-500 text-sm mb-4 hidden font-medium"></p>
                    <button type="submit" class="w-full bg-green-600 text-white py-3 px-4 rounded-xl font-bold hover:bg-green-700 transition duration-200 shadow-lg shadow-green-500/50 active:scale-[0.99]">
                        Register
                    </button>
                </form>
                <p class="mt-6 text-center text-sm text-gray-600">
                    Already registered? <button id="switch-to-login" class="text-indigo-600 hover:text-indigo-800 font-extrabold hover:underline">Log in here</button>
                </p>
            </div>
        </div>
    </div>


    <!-- MAIN APPLICATION CONTAINER (Hidden until authenticated) -->
    <div id="app-container" class="hidden max-w-6xl mx-auto">
        <!-- HEADER (Now contained within the app-container) -->
        <header class="mb-6 flex flex-col bg-white p-4 sm:p-6 rounded-2xl shadow-2xl">
            <!-- Title Section -->
            <div class="flex items-center justify-center lg:justify-start mb-2">
                <h1 class="text-3xl font-extrabold text-gray-800 flex items-center">
                    <svg class="inline w-7 h-7 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 0111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    Collaborative Location Share
                </h1>
            </div>

            <!-- Controls Section -->
            <div class="pt-4 border-t border-gray-100 flex flex-col lg:flex-row items-start lg:items-center space-y-4 lg:space-y-0 lg:space-x-4 w-full">
                
                <!-- User ID Display -->
                <span id="user-id-display" class="text-xs font-mono text-gray-500 bg-gray-100 p-2 rounded-lg truncate w-full lg:w-auto lg:flex-grow-0 min-w-[200px]">
                    Connecting...
                </span>
                
                <!-- Message Input Field and Button (Update Status Feature) -->
                <div id="message-control" class="hidden flex items-center space-x-2 w-full lg:flex-grow">
                    <input type="text" id="user-message-input" placeholder="Your status (visible on marker click)..." maxlength="100" class="flex-grow px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" />
                    <span id="message-status-indicator" class="text-xs text-gray-500 min-w-[50px] transition-opacity duration-300"></span>
                    <!-- Update Status Button -->
                    <button id="send-message-btn" class="px-3 py-2 text-white bg-indigo-500 hover:bg-indigo-600 font-semibold rounded-lg transition duration-150 ease-in-out shadow-md disabled:opacity-50" title="Send immediate status update" disabled>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                    </button>
                </div>
                
                <!-- Control Buttons -->
                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 w-full lg:w-auto lg:min-w-[400px]">
                    <button id="fit-to-all-btn" class="flex-grow px-4 py-2 text-white bg-gray-500 hover:bg-gray-600 font-semibold rounded-lg transition duration-150 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-gray-500" disabled>
                        Fit to All Users
                    </button>
                    <!-- Log Out Button -->
                    <button id="logout-btn" class="hidden flex-grow px-4 py-2 text-white bg-red-500 hover:bg-red-600 font-semibold rounded-lg transition duration-150 shadow-md">
                        Logout
                    </button>
                    <!-- Share Location Button (Toggle Tracking) -->
                    <button id="toggle-tracking-btn" class="hidden flex-grow px-4 py-2 text-white font-semibold rounded-lg transition duration-150 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 bg-green-500 hover:bg-green-600 focus:ring-green-500" disabled>
                        Start Sharing Location
                    </button>
                </div>
            </div>
        </header>

        <!-- Map container -->
        <div id="map" class=""></div>

        <!-- FOOTER (Now contained within the app-container) -->
        <footer class="mt-6 p-4 text-center text-gray-500 text-sm bg-white rounded-2xl shadow-lg border-t border-gray-100">
            <p>Collaborative Location Share - Real-Time Mapping Demo</p>
            <p class="text-xs mt-1 text-gray-400">Powered by Firebase & Google Maps API</p>
        </footer>
    </div>


    <!-- Firebase SDKs and Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        // Import enablePersistence for offline capability
        import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, getDoc, enablePersistence } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";

        // IMPORTANT: Set debug logging for Firestore
        setLogLevel('Debug');

        // Hardcoded Firebase configuration (Replace with actual if available)
        const userProvidedFirebaseConfig = {
            apiKey: "AIzaSyCbr-2Hvxg4AEfFb51lGoYYepxLOie4JiQ",
            authDomain: "track-your-journey.firebaseapp.com",
            projectId: "track-your-journey",
            storageBucket: "track-your-journey.firebasestorage.app",
            messagingSenderId: "766067811321",
            appId: "1:766067811321:web:0dadf42158bc72cafb9328",
            measurementId: "G-BS033MFRVY"
        };

        // Global variables required by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, analytics;
        let userId = 'anonymous'; // Default value, updated on successful auth
        /** @type {google.maps.Map} */
        let map;
        let isTracking = false; // Tracks if watchPosition is active
        let watchId = null;
        /** @type {Object<string, google.maps.Marker>} */
        const userMarkers = {}; 
        /** @type {Object<string, google.maps.InfoWindow>} */
        const infoWindows = {}; 
        
        let userMessage = ""; 
        let isMapCentered = false; // Flag to center map only on first successful location find
        
        /** @type {Object<string, google.maps.Polyline>} */
        const userPolylines = {}; 
        /** @type {Object<string, Array<{lat: number, lng: number}>>} */
        const userPaths = {};     
        
        // --- DOM Elements ---
        const toggleBtn = document.getElementById('toggle-tracking-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const userIdDisplay = document.getElementById('user-id-display');
        const mapContainer = document.getElementById('map');
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container'); 

        const loginCard = document.getElementById('login-card');
        const registerCard = document.getElementById('register-card');
        const fitToAllBtn = document.getElementById('fit-to-all-btn'); 
        
        // MESSAGE ELEMENTS
        const messageControl = document.getElementById('message-control'); 
        const messageInput = document.getElementById('user-message-input');
        const messageStatusIndicator = document.getElementById('message-status-indicator');
        const sendMessageBtn = document.getElementById('send-message-btn'); 

        // Login Form Elements
        const loginForm = document.getElementById('login-form');
        const loginEmail = document.getElementById('login-email');
        const loginPassword = document.getElementById('login-password');
        const loginShowPassword = document.getElementById('login-show-password');
        const loginError = document.getElementById('login-error');

        // Registration Form Elements
        const registerForm = document.getElementById('register-form');
        const registerUsername = document.getElementById('register-username'); 
        const registerEmail = document.getElementById('register-email');
        const registerPassword = document.getElementById('register-password');
        const registerConfirmPassword = document.getElementById('register-confirm-password');
        const registerShowPassword = document.getElementById('register-show-password');
        const registerError = document.getElementById('register-error');

        // --- Custom Google Maps Icon Definitions ---
        const MY_MARKER_ICON = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#4f46e5', // Indigo-600 (Self)
            fillOpacity: 1,
            strokeWeight: 4,
            strokeColor: '#e0e7ff', // Light Indigo outline
            scale: 8, 
        };
        const OTHER_MARKER_ICON = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#dc2626', // Red-600 (Others)
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: '#fca5a5', // Lighter Red outline
            scale: 6, 
        };


        // --- Utility Functions ---

        const getPublicCollectionPath = (collectionName) => {
            return `/artifacts/${appId}/public/data/${collectionName}`;
        };

        const getColorFromId = (id) => {
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            // Use a color with better contrast for the trace path
            const hex = "#" + "00000".substring(0, 6 - c.length) + c;
            
            // Slightly darken the generated color for better visibility as a dot
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return '#' + 
                Math.floor(r * 0.8).toString(16).padStart(2, '0') + 
                Math.floor(g * 0.8).toString(16).padStart(2, '0') + 
                Math.floor(b * 0.8).toString(16).padStart(2, '0');
        };
        
        /**
         * Returns options object for a dotted polyline.
         * @param {string} id User ID.
         * @param {boolean} isSelf Is the current user.
         * @returns {google.maps.PolylineOptions}
         */
        const getPolylineOptions = (id, isSelf) => {
            const lineColor = isSelf ? '#4f46e5' : getColorFromId(id); 
            const dotColor = lineColor;
            const dotScale = isSelf ? 4 : 3;
            const dotRepeat = isSelf ? '20px' : '15px';
            const dotOpacity = isSelf ? 1.0 : 0.8;

            return {
                geodesic: true,
                strokeOpacity: 0, // CRITICAL: Makes the actual line segment invisible
                strokeColor: lineColor, 
                strokeWeight: 0, // Ensure no thickness from solid line
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: dotScale,
                        fillColor: dotColor,
                        fillOpacity: dotOpacity,
                        strokeWeight: 0,
                    },
                    offset: '0',
                    repeat: dotRepeat // Spacing between the dots
                }],
            };
        };

        const toggleAppUI = (isAuthenticated) => {
            if (isAuthenticated) {
                authContainer.classList.add('hidden');
                appContainer.classList.remove('hidden');
                
                // Set body style for standard app layout
                document.body.classList.add('app-active-layout'); 
                document.body.classList.remove('flex', 'items-center', 'justify-center');
                
                toggleBtn.disabled = false;
                fitToAllBtn.disabled = false; 
                logoutBtn.classList.remove('hidden'); // Show Logout
                messageControl.classList.remove('hidden'); // Show Message Controls

            } else {
                authContainer.classList.remove('hidden');
                appContainer.classList.add('hidden');
                
                // Set body style for centered auth card
                document.body.classList.remove('app-active-layout');
                document.body.classList.add('flex', 'items-center', 'justify-center');
                
                toggleBtn.disabled = true;
                fitToAllBtn.disabled = true; 
                logoutBtn.classList.add('hidden'); // Hide Logout
                messageControl.classList.add('hidden'); // Hide Message Controls
            }
        };

        const togglePasswordVisibility = (type) => {
            if (type === 'login') {
                loginPassword.type = loginShowPassword.checked ? 'text' : 'password';
            } else if (type === 'register') {
                const isChecked = registerShowPassword.checked;
                registerPassword.type = isChecked ? 'text' : 'password';
                registerConfirmPassword.type = isChecked ? 'text' : 'password';
            }
        };
        
        const showModal = (message) => {
            const existingModal = document.getElementById('custom-modal');
            if (existingModal) existingModal.remove();

            const modalHtml = `
                <div id="custom-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300">
                    <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 md:w-1/3">
                        <h3 class="text-lg font-bold text-red-600 mb-4">Notification</h3>
                        <p class="text-gray-700 mb-6">${message}</p>
                        <button id="modal-close-btn" class="w-full bg-indigo-500 text-white py-2 rounded-lg font-semibold hover:bg-indigo-600 transition duration-150">
                            OK
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            document.getElementById('modal-close-btn').onclick = () => {
                document.getElementById('custom-modal').remove();
            };
        };


        // --- Firebase Initialization and Authentication ---

        // Function to check if the user was previously tracking and restart the service
        const checkAndRestartTracking = async () => {
            if (!db || !userId || userId === 'anonymous') return;

            const userDocRef = doc(db, getPublicCollectionPath('user_locations'), userId);
            
            // Check if a location document already exists for this user
            try {
                const docSnap = await getDoc(userDocRef);

                if (docSnap.exists() && docSnap.data().isTracking) {
                    console.log("Found existing tracking session, restarting geolocation.");
                    
                    // Set local state variables and restart the process
                    isTracking = true;
                    
                    // Reset the message from the document
                    userMessage = docSnap.data().message || '';
                    messageInput.value = userMessage;

                    // Update UI to 'Waiting' state temporarily
                    toggleBtn.textContent = 'Restarting tracking...';
                    toggleBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500', 'bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');
                    toggleBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');

                    // Restart the watchPosition loop
                    startTracking(); 
                }
            } catch (e) {
                console.error("Error checking for tracking status:", e);
            }
        };


        const initializeFirebase = async () => {
            try {
                app = initializeApp(userProvidedFirebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                getAnalytics(app); 
                
                // CRITICAL: Enable Firestore persistence for offline write queuing
                try {
                    await enablePersistence(db);
                    console.log("Firestore persistence enabled successfully.");
                } catch (err) {
                    if (err.code === 'failed-precondition') {
                        // Multiple tabs open, persistence can only be enabled in one.
                        console.warn("Firestore persistence failed: Multiple tabs open. Offline mode may not fully persist state.");
                    } else if (err.code === 'unimplemented') {
                        // The browser does not support all features needed for persistence.
                        console.error("Firestore persistence failed: Browser not supported.");
                    } else {
                        console.error("Firestore persistence failed unexpectedly:", err);
                    }
                }


                if (initialAuthToken) {
                    userIdDisplay.textContent = 'Authenticating...';
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Custom Token Sign-In Failed:", error);
                    }
                } else {
                    userIdDisplay.textContent = 'Please log in or register.';
                    toggleAppUI(false); // Ensure forms are visible if no token
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        // --- AUTH SUCCESS STATE ---
                        userId = user.uid;
                        const displayIdentifier = user.displayName || user.email || userId;
                        userIdDisplay.textContent = `User ID: ${displayIdentifier}`;
                        
                        toggleAppUI(true);

                        // Initial button style (will be overridden if tracking restarts)
                        if (!isTracking) {
                            toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500', 'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
                            toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
                            toggleBtn.classList.remove('hidden'); // Show Share Location Button
                            logoutBtn.classList.remove('hidden'); // Show Logout Button
                        }

                        setupRealTimeLocationListener();
                        // Check for persistence and restart tracking if needed
                        checkAndRestartTracking();

                    } else {
                        // --- AUTH SIGNED OUT STATE ---
                        userId = 'anonymous';
                        userIdDisplay.textContent = 'Please log in or register.';
                        toggleAppUI(false);
                        sendMessageBtn.disabled = true; 
                        // Clean up markers/polylines for all users
                        Object.keys(userMarkers).forEach(removeMarker);
                    }
                });


            } catch (error) {
                console.error("Error initializing Firebase:", error.message);
                userIdDisplay.textContent = 'Error: Check Console';
            }
        };

        // --- Auth Handlers (Same as before) ---
        const handleRegistration = async (e) => {
            e.preventDefault();
            registerError.classList.add('hidden');
            const username = registerUsername.value.trim();
            const email = registerEmail.value;
            const password = registerPassword.value;
            const confirmPassword = registerConfirmPassword.value;

            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match.';
                registerError.classList.remove('hidden');
                return;
            }
            if (password.length < 6) {
                registerError.textContent = 'Password must be at least 6 characters.';
                registerError.classList.remove('hidden');
                return;
            }
            if (username.length === 0) {
                 registerError.textContent = 'Username is required.';
                registerError.classList.remove('hidden');
                return;
            }

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await updateProfile(userCredential.user, { displayName: username });
            } catch (error) {
                console.error("Registration Error:", error.message);
                registerError.textContent = `Registration failed: ${error.message}`;
                registerError.classList.remove('hidden');
            }
        };

        const handleLogin = async (e) => {
            e.preventDefault();
            loginError.classList.add('hidden');
            const email = loginEmail.value;
            const password = loginPassword.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Login Error:", error.message);
                loginError.textContent = 'Login failed. Check email and password.';
                loginError.classList.remove('hidden');
            }
        };

        const handleLogout = async () => {
            if (isTracking) {
                // Ensure we stop tracking and delete the doc before signing out
                await stopTracking(); 
            }
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Logout Error:", error.message);
                showModal("Logout failed. Please try again.");
            }
        };
        
        const sendMessageUpdate = async () => {
            if (!isTracking) {
                messageStatusIndicator.textContent = 'Track to send.';
                messageStatusIndicator.classList.remove('hidden');
                setTimeout(() => { messageStatusIndicator.textContent = ''; }, 2000);
                return;
            }

            const myMarker = userMarkers[userId];
            if (!myMarker) {
                messageStatusIndicator.textContent = 'Awaiting location to send.';
                messageStatusIndicator.classList.remove('hidden');
                setTimeout(() => { messageStatusIndicator.textContent = ''; }, 2000);
                return;
            }
            
            userMessage = messageInput.value.trim();
            messageStatusIndicator.textContent = 'Sending...';
            messageStatusIndicator.classList.remove('hidden');

            const pos = myMarker.getPosition();
            
            // Only update the message property, but we must update the doc to trigger the snapshot listener
            await updateFirestoreLocation(pos.lat(), pos.lng(), true, true);
            
            const currentUser = auth.currentUser;
            const displayId = currentUser.displayName || currentUser.email || userId;
            updateMarker(userId, pos.lat(), pos.lng(), new Date().getTime(), displayId, userMessage);

            messageStatusIndicator.textContent = 'Status Sent!';
            setTimeout(() => {
                messageStatusIndicator.textContent = '';
                messageStatusIndicator.classList.add('hidden');
            }, 1500);
        };


        // --- Geolocation and Firestore Data Management (Same as before, now with offline persistence) ---
        
        /**
         * Updates or deletes the current user's location document in Firestore.
         * @param {number} lat Latitude.
         * @param {number} lng Longitude.
         * @param {boolean} isTracking True if user is actively tracking.
         * @param {boolean} isMessageUpdate True if this is an explicit message update, prevents path recording.
         */
        const updateFirestoreLocation = async (lat, lng, isTracking, isMessageUpdate = false) => {
            if (!db || !userId || userId === 'anonymous') return;

            const userDocRef = doc(db, getPublicCollectionPath('user_locations'), userId);

            if (isTracking) {
                const currentUser = auth.currentUser;
                const displayId = currentUser.displayName || currentUser.email || userId;
                
                // Store tracking intent and location data
                const data = {
                    timestamp: new Date().getTime(),
                    displayId: displayId, 
                    isTracking: true, // Key for persistence across refresh
                    message: userMessage || 'No status set',
                    lat: lat,
                    lng: lng
                };

                // This write operation will be queued if the user is offline
                await setDoc(userDocRef, data, { merge: true });

            } else {
                // User intentionally stopped tracking, delete the document. This deletion is also queued.
                await deleteDoc(userDocRef);
                removeMarker(userId); 
            }
        };

        const geoSuccess = (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const pos = { lat, lng };

            // Update UI to final tracking state (Red Button)
            isTracking = true;
            sendMessageBtn.disabled = false;
            sendMessageBtn.classList.remove('hidden');
            toggleBtn.textContent = 'Stop Sharing Location';
            toggleBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500', 'bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
            toggleBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');


            // 1. Update own location in public Firestore (will be queued if offline)
            updateFirestoreLocation(lat, lng, true);

            // 2. Immediately update the local map marker for the current user 
            const currentUser = auth.currentUser;
            const displayId = currentUser.displayName || currentUser.email || userId;
            updateMarker(userId, lat, lng, new Date().getTime(), displayId, userMessage); 
            
            // 3. Center map and zoom in on start (if flag is set)
            if (map && isMapCentered) { 
                 map.setCenter(pos);
                 map.setZoom(15); 
                 isMapCentered = false; 
            }
        };

        const geoError = (error) => {
            console.error("Geolocation Error:", error.message);
            
            let errorMsg = `Location Error: ${error.message}. Please ensure location permissions are set to 'Allow' (not 'Ask Next Time') in your browser settings.`;
            if (error.code === 1) { 
                 errorMsg = "Location permission denied. Please check your device and browser settings to allow location access.";
            } else if (error.code === 3) { 
                 errorMsg = "Location request timed out. Please check network/permissions and retry.";
            }
            showModal(errorMsg);

            // Revert state if geolocation fails while attempting to start/restart
            if (isTracking && watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            isTracking = false;
            sendMessageBtn.disabled = true; 
            sendMessageBtn.classList.add('hidden'); 
            toggleBtn.textContent = 'Start Sharing Location';
            toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500', 'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
            toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');
            
            // CRITICAL: Since watchPosition failed, ensure the Firestore document is removed 
            // if it was set to true (e.g., during an automatic restart attempt).
            updateFirestoreLocation(0, 0, false); 

            // FIX: Manually remove the stale marker from the map since tracking stopped
            if (auth.currentUser && auth.currentUser.uid) {
                 removeMarker(auth.currentUser.uid); 
            }
        };

        const startTracking = () => {
            if (!navigator.geolocation) {
                showModal("Geolocation is not supported by this browser.");
                return;
            }

            // Only set this flag if this is the *very first* manual start
            if (!isTracking) {
                 isMapCentered = true;
            }
           
            // Update UI to 'Waiting' state immediately (Yellow Button)
            isTracking = true;
            sendMessageBtn.disabled = true; 
            sendMessageBtn.classList.remove('hidden'); 
            toggleBtn.textContent = 'Waiting for location...';
            toggleBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500', 'bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500');
            toggleBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');

            // --- Geolocation setup ---
            if (watchId !== null) {
                // Clear any existing watch to prevent duplicates
                 navigator.geolocation.clearWatch(watchId);
            }
            
            watchId = navigator.geolocation.watchPosition(geoSuccess, geoError, {
                enableHighAccuracy: true,
                maximumAge: 0, 
                timeout: 15000 
            });
        };

        const stopTracking = async () => {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            isTracking = false;
            sendMessageBtn.disabled = true; 
            sendMessageBtn.classList.add('hidden'); 
            toggleBtn.textContent = 'Start Sharing Location';
            toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'focus:ring-red-500', 'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-500');
            toggleBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'focus:ring-green-500');

            // CRITICAL: Delete the document to remove persistence flag
            await updateFirestoreLocation(0, 0, false);
        };

        // --- Map and Marker Management (Same as before) ---
        
        const fitMapToBounds = () => {
            const activeMarkers = Object.keys(userMarkers);
            if (activeMarkers.length === 0) {
                map.setCenter({ lat: 0, lng: 0 });
                map.setZoom(2);
                return;
            }

            const bounds = new google.maps.LatLngBounds();
            
            activeMarkers.forEach(id => {
                bounds.extend(userMarkers[id].getPosition());
            });

            if (activeMarkers.length === 1) {
                 map.panTo(userMarkers[activeMarkers[0]].getPosition());
                 if (map.getZoom() < 10) map.setZoom(15); 
            } else {
                map.fitBounds(bounds);
            }
        };


        const initializeMap = () => {
            map = new google.maps.Map(mapContainer, {
                center: { lat: 0, lng: 0 }, 
                zoom: 2,
                mapId: "DEMO_MAP_ID"
            });
            console.log("Google Map initialized.");
        };

        const setupRealTimeLocationListener = () => {
            if (!db) return;

            const colRef = collection(db, getPublicCollectionPath('user_locations'));

            // onSnapshot will now listen to local cached data first when offline
            onSnapshot(colRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const targetUserId = change.doc.id;
                    const displayId = data.displayId || targetUserId; 
                    const message = data.message || ''; 
                    
                    if (targetUserId === userId) {
                        // Handle changes for the current user only
                        if (change.type === "removed" || !data.isTracking) {
                            // If the document was removed by stopTracking or logout, clean local state
                            if (isTracking) {
                                if (watchId !== null) {
                                    navigator.geolocation.clearWatch(watchId);
                                    watchId = null;
                                }
                                isTracking = false;
                            }
                            removeMarker(targetUserId);
                        }
                        // Update local message state
                        if (data.isTracking) {
                            userMessage = message;
                            messageInput.value = message;
                        }
                        return;
                    }

                    // Handle changes for other users
                    if (change.type === "removed" || !data.isTracking) {
                        removeMarker(targetUserId);
                    } else if (change.type === "added" || change.type === "modified") {
                        if (data.lat !== undefined && data.lng !== undefined && data.isTracking) {
                            updateMarker(targetUserId, data.lat, data.lng, data.timestamp, displayId, message);
                        }
                    }
                });
            }, (error) => {
                console.error("Error listening to Firestore location updates:", error);
            });
        };
        

        const updateMarker = (id, lat, lng, timestamp, displayId, message) => {
            const isSelf = id === userId;
            const position = { lat: lat, lng: lng };
            const icon = isSelf ? MY_MARKER_ICON : OTHER_MARKER_ICON;
            const timeString = new Date(timestamp).toLocaleTimeString();
            const markerTitle = isSelf ? `👑 Your Location (You: ${displayId})` : `📍 User: ${displayId}`;

            let marker = userMarkers[id];
            let infoWindow = infoWindows[id];

            if (marker) {
                marker.setPosition(position);
                marker.setIcon(icon);
                marker.setTitle(markerTitle);
            } else {
                marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: markerTitle, 
                    icon: icon,
                });

                userMarkers[id] = marker;

                infoWindow = new google.maps.InfoWindow({ content: 'Location Info' });
                infoWindows[id] = infoWindow;

                marker.addListener('click', () => {
                    Object.values(infoWindows).forEach(iw => iw.close());
                    
                    const messageToShow = isSelf ? userMessage : message;

                    const popupContent = `
                        <div class="info-window p-1">
                            <div class="text-base font-bold mb-1" style="color: ${isSelf ? '#4f46e5' : '#dc2626'};">${markerTitle}</div>
                            <div class="text-sm font-semibold text-gray-800 break-words mt-1">Status: ${messageToShow || 'No status set'}</div>
                            <div class="text-xs text-gray-500 mt-1">Lat: ${lat.toFixed(6)}</div>
                            <div class="text-xs text-gray-500">Lng: ${lng.toFixed(6)}</div>
                            <div class="text-xs text-gray-500">Last Seen: ${timeString}</div>
                        </div>
                    `;
                    infoWindow.setContent(popupContent);
                    
                    infoWindow.open({ anchor: marker, map: map, shouldFocus: false });
                });
            }

            if (infoWindow && infoWindow.getMap() === map) { 
                  const messageToShow = isSelf ? userMessage : message;

                  const updatedContent = `
                        <div class="info-window p-1">
                            <div class="text-base font-bold mb-1" style="color: ${isSelf ? '#4f46e5' : '#dc2626'};">${markerTitle}</div>
                            <div class="text-sm font-semibold text-gray-800 break-words mt-1">Status: ${messageToShow || 'No status set'}</div>
                            <div class="text-xs text-gray-500 mt-1">Lat: ${lat.toFixed(6)}</div>
                            <div class="text-xs text-gray-500">Lng: ${lng.toFixed(6)}</div>
                            <div class="text-xs text-gray-500">Last Seen: ${timeString}</div>
                        </div>
                    `;
                  infoWindow.setContent(updatedContent);
            }

            if (!userPaths[id]) {
                userPaths[id] = [];
            }
            
            const lastPos = userPaths[id][userPaths[id].length - 1];
            // Only add new path segment if position is actually different (avoids recording static points)
            const isDifferent = !lastPos || (lastPos.lat.toFixed(6) !== lat.toFixed(6) || lastPos.lng.toFixed(6) !== lng.toFixed(6));
            
            if (isDifferent) {
                userPaths[id].push(position);
            }

            let polyline = userPolylines[id];
            const polylineOptions = getPolylineOptions(id, isSelf); // Get dotted style options

            if (polyline) {
                polyline.setPath(userPaths[id]);
                // Update the style options (important for self-vs-other color/size differences)
                polyline.setOptions(polylineOptions); 
            } else {
                polyline = new google.maps.Polyline({
                    path: userPaths[id],
                    ...polylineOptions, // Spread the dotted options
                    map: map,
                });
                userPolylines[id] = polyline;
            }
        };

        const removeMarker = (id) => {
            if (userMarkers[id]) {
                userMarkers[id].setMap(null);
                delete userMarkers[id];
            }
            if (userPolylines[id]) {
                userPolylines[id].setMap(null); 
                delete userPolylines[id];
            }
            if (userPaths[id]) {
                delete userPaths[id]; 
            }
            if(infoWindows[id]) {
                infoWindows[id].close();
                delete infoWindows[id];
            }
        };

        // --- Event Listeners and Initial Setup ---

        toggleBtn.addEventListener('click', async () => {
            if (isTracking) {
                await stopTracking();
            } else {
                startTracking();
            }
        });
        
        sendMessageBtn.addEventListener('click', sendMessageUpdate);
        fitToAllBtn.addEventListener('click', fitMapToBounds); // Explicitly called only by button

        // Toggle login/register card views
        document.getElementById('switch-to-register').addEventListener('click', () => {
            loginCard.classList.add('hidden');
            registerCard.classList.remove('hidden');
            loginError.classList.add('hidden'); 
            registerError.classList.add('hidden');
        });
        document.getElementById('switch-to-login').addEventListener('click', () => {
            registerCard.classList.add('hidden');
            loginCard.classList.remove('hidden');
            registerError.classList.add('hidden'); 
            loginError.classList.add('hidden');
        });

        // Form submissions
        loginForm.addEventListener('submit', handleLogin);
        registerForm.addEventListener('submit', handleRegistration);
        logoutBtn.addEventListener('click', handleLogout);

        // Password visibility toggles
        loginShowPassword.addEventListener('change', () => togglePasswordVisibility('login'));
        registerShowPassword.addEventListener('change', () => togglePasswordVisibility('register'));

        window.onload = async () => {
            await initializeFirebase();

            const mapLoadCheck = setInterval(() => {
                if (typeof google !== 'undefined' && google.maps) {
                    clearInterval(mapLoadCheck);
                    initializeMap(); 
                }
            }, 100);
        };
    </script>
</body>
</html>
